# Домашнее задание к занятию «Структурные паттерны: Delegate, Singleton, Factory»

С этого задания мы начинаем погружаться в архитектурные паттерны, широко используемые в промышленной разработке. Главная задача на сегодня — разобраться, как работает механика паттернов **делегирования и синглтона** (в задаче 1), а также **фабрики** (в задаче 2).

Используйте приложение Navigation **после** завершения предыдущей домашней работы №3.

## Правила выполнения домашней работы

* Все задачи обязательны к выполнению для получения зачёта, кроме задач со звёздочкой.
* Изучите [инструкцию](https://github.com/netology-code/iosint-homeworks/blob/main/Pull%20request's%20guideline.md) по сдаче домашних заданий через pull request. В поле для сдачи работы прикрепите ссылку на ваш проект на Github.
* Любые вопросы по решению задач задавайте в чате учебной группы.

## Задача 1

1. Сделаем как **синглтон** специальный сервис для проверки логина и пароля под названием `Checker`. Пока этот сервис будет иметь один интерфейсный метод для проверки логина и пароля, введённого пользователем.
2. Создайте новый класс `Checker` и сделайте его синглтоном.
3. В классе `Checker` сделайте **приватные** свойства `login` и `password`, пусть они будут константами и будут иметь выбранные вами значения в заранее заданном виде.
4. В классе `Checker` сделайте метод `check`, который будет принимать логин и пароль, введенные пользователем и возвращать true, если и логин и пароль будут совпадать и false — если нет. 
5. Создайте новый протокол `LoginViewControllerDelegate`, для него пропишите один метод `check`, который будет использовать созданный выше синглтон Checker. 
6. Для класса `LoginViewController` сделайте свойство `loginDelegate` с типом `LoginViewControllerDelegate`. Метод делегата будет проверять значения, введённые в текстовых полях контроллера. Напрямую вызывать из контроллера сервис `Checker` в этой работе нельзя. 
7. Создайте новую структуру `LoginInspector` и подпишите её на протокол `LoginViewControllerDelegate`; сделайте в ней реализацию метода протокола. `LoginInspector` должен проверять соответствие введённого логина и пароля с помощью синглтона `Checker`. Важный момент: чтобы делегат мог сообщить контроллеру результат проверки логина и пароля, метод протокола делегата должен содержать возвращаемое значение.
8. Внедрите зависимость контроллера `LoginViewController` от `LoginInspector`, то есть присвойте значение свойству делегата в классе `SceneDelegate` или `AppDelegate`.
9. Реализуйте в `LoginViewController` проверку логина и пароля, введённого пользователем с помощью `loginDelegate`. Выведите сообщение о неверном логине или пароле с помощью `UIAlertController`, если они неверные. Подумайте, как логично интегрировать сделанный в предыдущем задании `UserService`, который предоставляет информацию о пользователе для его профиля, c проверкой на входе логина и пароля c использованием `LoginInspector`.
10. Проверьте, что если в вашем приложении введены неверные логин или пароль, то выводится предупреждение, а если они совпадают с зарегистрированными, то пользователь попадает на экран профиля. Пусть вас не смущает, что логин и пароль зарегистрированы статично. Мы это усовершенствуем позднее.

## Задача 2

1. Сделаем **фабрику** для производства объектов проверки пароля.
2. Создайте новый протокол `LoginFactory` с одним методом без параметров `makeLoginInspector`, который будет возвращать `LoginInspector`.
3. Сделайте новую структуру `MyLoginFactory`, которая будет удовлетворять требованиям протокола `LoginFactory` и содержать генератор экземпляра `LoginInspector`
4. Вынесите генерацию `LoginInspector` в `SceneDelegate (или AppDelegate)` через фабрику: теперь экземпляр делегата для `LoginViewController` должен создаваться через фабрику, а не напрямую.
5. Проверьте, что теперь сервис проверки логина и пароля успешно работает через фабрику. Конечно, сейчас фабрика не очень нужна для генерации единственного экземпляра одного класса или структуры, но зато вы освоили сам метод, паттерн фабрики и теперь можете его использовать для генерации изделий массового спроса в коде ваших будущих приложений.
